/* Execution: java -jar ../../lib/cup-11b.jar -locations ../../cup/Grammar.cup (ejecutar en: /src/sinctactic) */
package sintactic;

import java_cup.runtime.*;
import java.util.LinkedList;
import java.util.ArrayList;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import sintactic.symbols.CrotoSymbol;
import semantic.Type;
import semantic.symbols.*;

parser code  {: 
   @Override
    public void report_error(String message, Object info) {
        if (info instanceof CrotoSymbol) {
            CrotoSymbol cs = (CrotoSymbol) info;
            System.err.println(message + " at line " + cs.getLeft().getLine() + ", column " + cs.getLeft().getColumn());
        }
    }
    
    public void report_error(String message, Object info, String message2) {
        if (info instanceof CrotoSymbol) {
            CrotoSymbol cs = (CrotoSymbol) info;
            if (cs.value != null)
                System.err.println(message + " at \"" + cs.value + "\" at line " + cs.getLeft().getLine() + ", column " + cs.getLeft().getColumn() + ": " + message2);
            else 
                System.err.println(message + " at \"" + cs.getName() + "\" at line " + cs.getLeft().getLine() + ", column " + cs.getLeft().getColumn() + ": " + message2);
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) {
        done_parsing();
        report_error(message, info);
        System.exit(0);
    }

    @Override
    public void syntax_error(Symbol cur_token) {
        report_error("Sintax error", cur_token, expecetd_tokens_names());
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        report_fatal_error("Fatal sintax error", cur_token);
    }

    protected String expecetd_tokens_names() {
        LinkedList<String> list = new LinkedList<>();
        for (Integer expected : expected_token_ids()) list.add(symbl_name_from_id(expected));
        if(!list.isEmpty()) return "instead expected token are " + list;
        else return "";
    }
:};

/* Types */
terminal BOOLEAN, INTEGER;

/* Keywords */
terminal IF, ELSE;
terminal WHILE; // loops
terminal BREAK;
terminal RETURN;
terminal CONSTANT;
terminal CROTOFUNC; // Functions
terminal MAIN;

/* Operators */
terminal ASSIGNMENT; // Assignment
terminal ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION; // Aritmetic
terminal EQUAL, DIFFERENT, GREATER, LOWER, GREATER_EQUAL, LOWER_EQUAL; // Comparation
terminal AND, OR, NOT; // Logical

/* Other */
terminal SEMICOLON, COMMA; // Punctuation
terminal LPAREN, RPAREN, LBRACE, RBRACE; // Separators

terminal java.lang.Integer INTEGER_VALUE;
terminal java.lang.Boolean BOOLEAN_VALUE;
terminal java.lang.String IDENTIFIER;

non terminal Program                            program;
non terminal Method                             main;
non terminal ArrayList<Method>                  methods;
non terminal Method                             method;
non terminal ArrayList<Method.Parameter>        param_list;
non terminal Method.Parameter                   param;
non terminal Type                               type;
non terminal Identifier                         id;
non terminal CodeBlock                          code_block;
non terminal VarDeclaration                     var_declaration;
non terminal Expression                         expression, boolean_expression, literal;
non terminal ArrayList<Expression>              expression_list;
non terminal Statement                          statement;
non terminal Statement.If                       if_statement;
non terminal Structure.Instruction              instruction;
non terminal ArrayList<Structure.Instruction>   instructions;

precedence nonassoc ASSIGNMENT;
precedence left     OR;
precedence left     AND;
precedence left     EQUAL, DIFFERENT, GREATER, LOWER, GREATER_EQUAL, LOWER_EQUAL;
precedence left     ADDITION, SUBTRACTION;
precedence left     MULTIPLICATION, DIVISION;
precedence right    NOT;
precedence right    RETURN;

start with program;

program         ::= main:m 
                    {: RESULT = new Program(m); :}
                | methods:ms main:m 
                    {: RESULT = new Program(m, ms); :};

main            ::= CROTOFUNC MAIN LPAREN RPAREN LBRACE code_block:cb RBRACE 
                    {: RESULT = new Method(new Identifier("main"), cb, cbxleft.getLine(), cbxleft.getColumn()); :};

methods         ::= method:m 
                    {: RESULT = new ArrayList<Method>(); RESULT.add(m); :}
                | methods:ms method:m 
                    {: RESULT = ms; ms.add(m);:};

method          ::= CROTOFUNC id:id LPAREN RPAREN LBRACE code_block:cb RBRACE 
                    {: RESULT = new Method(id, cb, idxleft.getLine(), idxleft.getColumn()); :}
                | CROTOFUNC type:t id:id LPAREN RPAREN LBRACE code_block:cb RETURN expression:e SEMICOLON RBRACE 
                    {: RESULT = new Method(t,id, cb, e, idxleft.getLine(), idxleft.getColumn()); :}
                | CROTOFUNC id:id LPAREN param_list:pl RPAREN LBRACE code_block:cb RBRACE 
                    {: RESULT = new Method(id, pl, cb, idxleft.getLine(), idxleft.getColumn()); :}
                | CROTOFUNC type:t id:id LPAREN param_list:pl RPAREN LBRACE code_block:cb RETURN expression:e SEMICOLON RBRACE 
                    {: RESULT = new Method(t,id, pl, cb, e, idxleft.getLine(), idxleft.getColumn()); :};

param_list      ::= param:p 
                    {: RESULT = new ArrayList<Method.Parameter>(); RESULT.add(p);:}
                | param_list:pl COMMA param:p 
                    {: RESULT = pl; pl.add(p); :};

param           ::= type:t id:id
                    {: RESULT = new Method.Parameter(t,id,txleft.getLine(),txleft.getColumn()); :};

type            ::= BOOLEAN 
                    {: RESULT = Type.BOOLEAN; :}
                | INTEGER
                    {: RESULT = Type.INTEGER; :};

id              ::= IDENTIFIER:id
                    {: RESULT = new Identifier(id, idxleft.getLine(), idxleft.getColumn()); :};

literal         ::= INTEGER_VALUE:val 
                    {: RESULT = new Expression.Literal(Type.INTEGER, val, valxleft.getLine(), valxleft.getColumn()); :}
                | BOOLEAN_VALUE:val
                    {: RESULT = new Expression.Literal(Type.BOOLEAN, val, valxleft.getLine(), valxleft.getColumn()); :};

code_block      ::=  {:RESULT = new CodeBlock();:}
                | instructions:ins 
                    {: RESULT = new CodeBlock(ins, insxleft.getLine(),  insxleft.getColumn()); :};


instructions    ::= instruction:i
                    {: RESULT = new ArrayList(); RESULT.add(i);:}
                | instructions:list instruction:i 
                    {: RESULT = list; list.add(i); :};

instruction     ::= statement:s
                    {: RESULT = s; :}
                | var_declaration:d
                    {: RESULT = d; :};

var_declaration ::= CONSTANT type:t id:id SEMICOLON
                    {: RESULT = new VarDeclaration(true, t, id, txleft.getLine(), txleft.getColumn()); :}
                | CONSTANT type:t id:id ASSIGNMENT expression:e SEMICOLON 
                    {: RESULT = new VarDeclaration(true, t, id, e, txleft.getLine(), txleft.getColumn()); :}
                | type:t id:id SEMICOLON 
                    {: RESULT = new VarDeclaration(false, t, id, txleft.getLine(), txleft.getColumn()); :}
                | type:t id:id ASSIGNMENT expression:e SEMICOLON 
                    {: RESULT = new VarDeclaration(false, t, id, e, txleft.getLine(), txleft.getColumn()); :};

expression      ::= expression:el ADDITION expression:er
                    {: RESULT = new Expression.Arithmetic(el, er, Expression.Arithmetic.Type.ADDITION, elxleft.getLine(), elxleft.getColumn()); :}
                | expression:el SUBTRACTION expression:er
                    {: RESULT = new Expression.Arithmetic(el, er, Expression.Arithmetic.Type.SUBTRACTION, elxleft.getLine(), elxleft.getColumn()); :}
                | expression:el MULTIPLICATION expression:er
                    {: RESULT = new Expression.Arithmetic(el, er, Expression.Arithmetic.Type.MULTIPLICATION, elxleft.getLine(), elxleft.getColumn()); :}
                | expression:el DIVISION expression:er
                    {: RESULT = new Expression.Arithmetic(el, er, Expression.Arithmetic.Type.DIVISION, elxleft.getLine(), elxleft.getColumn()); :}
                | LPAREN expression:e RPAREN
                    {: RESULT = e; :}
                | boolean_expression:b 
                    {: RESULT = b; :}
                | id:id
                    {: RESULT = new Expression.Id(id, idxleft.getLine(), idxleft.getColumn()); :}
                | id:id LPAREN expression_list:args RPAREN
                    {: RESULT = new Expression.FunctionCall(id, args, idxleft.getLine(), idxleft.getColumn()); :}
                | id:id LPAREN RPAREN
                    {: RESULT = new Expression.FunctionCall(id, idxleft.getLine(), idxleft.getColumn()); :}
                | literal:l
                    {: RESULT = l; :}
                | error;

boolean_expression ::= expression:el EQUAL expression:er
                    {:RESULT = new Expression.Boolean(el, er, Expression.Boolean.Type.EQUAL, elxleft.getLine(), elxleft.getColumn()); :}
                | expression:el DIFFERENT expression:er
                    {:RESULT = new Expression.Boolean(el, er, Expression.Boolean.Type.DIFFERENT, elxleft.getLine(), elxleft.getColumn()); :}
                | expression:el GREATER expression:er
                    {:RESULT = new Expression.Boolean(el, er, Expression.Boolean.Type.GREATER, elxleft.getLine(), elxleft.getColumn()); :}
                | expression:el LOWER expression:er
                    {:RESULT = new Expression.Boolean(el, er, Expression.Boolean.Type.LOWER, elxleft.getLine(), elxleft.getColumn()); :}
                | expression:el GREATER_EQUAL expression:er
                    {:RESULT = new Expression.Boolean(el, er, Expression.Boolean.Type.GREATER_EQUAL, elxleft.getLine(), elxleft.getColumn()); :}
                | expression:el LOWER_EQUAL expression:er
                    {:RESULT = new Expression.Boolean(el, er, Expression.Boolean.Type.LOWER_EQUAL, elxleft.getLine(), elxleft.getColumn()); :}
                | expression:el AND expression:er
                    {:RESULT = new Expression.Boolean(el, er, Expression.Boolean.Type.AND, elxleft.getLine(), elxleft.getColumn()); :}
                | expression:el OR expression:er
                    {:RESULT = new Expression.Boolean(el, er, Expression.Boolean.Type.OR, elxleft.getLine(), elxleft.getColumn()); :}
                | NOT expression:er
                    {: RESULT = new Expression.Boolean(er, Expression.Boolean.Type.NOT,erxleft.getLine(),erxleft.getColumn()); :};

expression_list ::= expression_list:el COMMA expression:e
                    {: RESULT = el; el.add(e); :}
                | expression:e
                    {: RESULT = new ArrayList<Expression>(); RESULT.add(e); :};

statement       ::= id:id ASSIGNMENT expression:e SEMICOLON 
                    {:RESULT = new Statement.Assignment(id,e,idxleft.getLine(), idxleft.getColumn()); :}
                | id:id LPAREN RPAREN SEMICOLON 
                    {:RESULT = new Statement.FunctionCall(id,idxleft.getLine(), idxleft.getColumn()); :}
                | id:id LPAREN expression_list:expr RPAREN SEMICOLON
                    {:RESULT = new Statement.FunctionCall(id,expr,idxleft.getLine(), idxleft.getColumn()); :}
                | if_statement:i
                    {:RESULT = i;:}
                | WHILE:w LPAREN expression:e RPAREN LBRACE code_block:cb RBRACE
                    {:RESULT = new Statement.While(e,cb,wxleft.getLine(),wxleft.getColumn()); :}
                | BREAK:b SEMICOLON
                    {:RESULT = new Statement.Break(bxleft.getLine(),bxleft.getColumn()); :}
                | error;


if_statement    ::= IF:i LPAREN expression:e RPAREN LBRACE code_block:cb RBRACE 
                    {: RESULT = new Statement.If(e,cb,ixleft.getLine(),ixleft.getColumn()); :}
                | IF:i LPAREN expression:e RPAREN LBRACE code_block:cb RBRACE ELSE if_statement:ifst 
                    {: RESULT = new Statement.If(e,cb,ifst,ixleft.getLine(),ixleft.getColumn()); :}
                | IF:i LPAREN expression:e RPAREN LBRACE code_block:cbif RBRACE ELSE LBRACE code_block:cbelse RBRACE 
                    {: RESULT = new Statement.If(e,cbif,cbelse,ixleft.getLine(),ixleft.getColumn()); :};