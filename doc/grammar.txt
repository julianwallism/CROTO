/* Literal */
literal -> STRING_VALUE | INTEGER_VALUE | FLOAT_VALUE | CHAR_VALUE

/* Types */
type -> primitive_type | reference_type
primitive_type -> numeric_type | BOOLEAN
numeric_type -> integral_type | FLOAT
integral_type -> INTEGER | CHAR
reference_type -> array_type
array_type -> primitive_type dims | IDENTIFIER dims // int[] array o int array[]

/* Modifiers */
modifier_opt -> modifier | LAMBDA
modifier -> CONST

/* Variables */
field_declaration -> modifier_opt type variable_declarators SEMICOLON
variable_declarators -> variable_declarator | variable_declarators COMMA variable_declarator
variable_declarator -> variable_declarator_id | variable_declarator_id EQUAL variable_initializer
variable_declarator_id -> IDENTIFIER | variable_declarator_id LBRACK RBRACK /?? esto debe ser asi por los arraysÂ¿? ni idea
variable_initializer -> expression | array_initializer

/* Array Initializer */
array_initializer -> LBRACE variable_initializers COMMA RBRACE | LBRACE variable_initializers RBRACE | LBRACE COMMA RBRACE | LBRACE RBRACE
variable_initializers -> variable_initializer | variable_initializers COMMA variable_initializer

/* Method */
mthd_full -> mthd_header block
mthd_header -> CROTOFUNC type mthd_declarator | CROTOFUNC mthd_declarator
mthd_declarator -> IDENTIFIER LPAREN f_parameter_list_opt RPAREN

f_parameter_list_opt -> LAMBDA | f_parameter_list_opt
f_parameter_list -> f_parameter | f_parameter_list COMMA f_parameter
f_parameter -> type variable_declarator_id | CONST type variable_declarator_id

/* Code Blocks */
block -> LBRACE block_statements_opt RBRACE
block_statements_opt -> LAMBDA | block_statements
block_statements -> block_statement | block_statements block_statement
block_statement -> local_variable_declaration_statement | statement
local_variable_declaration_statement -> local_variable_declaration SEMICOLON
local_variable_declaration -> type variable_declarators | CONST type variable_declarators

/* Statements */
statement -> statement_w_no_trailing_substatement | if_statement | while_statement | for_statement
statement_expression_list -> statement_expression | statement_expression_list COMMA statement_expression
statement_expression -> assignment
                        |	preincrement_expression
                        |	predecrement_expression
                        |	postincrement_expression
                        |	postdecrement_expression
                        |	method_invocation


/* Switch */ 
switch_statement  -> SWITCH LPAREN statement RPAREN LBRACE cases default RBRACE 
cases  -> case cases | LAMBDA
case  -> CASE expression COLON statement
default  -> default statement | LAMBDA

/* If */
if_statement -> IF LPAREN expression RPAREN LBRACE statement RBRACE else_statements

/* Else */ 
else_statements -> ELSE LBRACE statement RBRACE statement | ELSE if_statement | statement

/* While */
while_statement -> WHILE LPAREN expression RPAREN LBRACE statement RBRACE

/* For */
for_statement -> FOR LPAREN for_init SEMICOLON expression_opt SEMICOLON for_updt RPAREN RBRACE statement LBRACE statement
for_init -> statement_expression_list |	local_variable_declaration | LAMBDA
for_updt -> statement_expression_list | LAMBDA

/* Expressions */
primary -> primary_not_array | array_creation_expression
primary_not_array -> literal | LPAREN expression RPAREN | field_access | method_invocation | array_access 

/* Argument List */
argument_list_opt -> argument_list | LAMBDA
argument_list -> expression | argument_list COMMA expression

/* Arrays */ // int[][] array = crotomemoryallocate int[4][5];
array_access -> IDENTIFIER LBRACK expression RBRACK | primary_not_array LBRACK expression RBRACK

/* Methods */
method_invocation -> IDENTIFIER LPAREN argument_list_opt RPAREN

/* Postfix */
postfix_expression -> primary | IDENTIFIER | postincrement_expression | postdecrement_expression
post_increment_expression -> postfix_expression INCREMENT
post_decrement_expression -> postfix_expression DECREMENT


unary_expression -> preincrement_expression | predecrement_expression | ADDITION unary_expression | MINUS unary_expression | unary_expression_not_plus_minus


expression_opt -> expression | LAMBDA