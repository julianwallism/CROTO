/* Execution: java -jar ../../lib/cup-11b.jar -locations Syntaxer.cup (ejecutar en: /src/sinctactic) */
package sintactic;
import java_cup.runtime.*;
import java.util.LinkedList;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import sintactic.symbols.CrotoSymbol;

parser code  {: 

    private TablaSimbols ts;

   @Override
    public void report_error(String message, Object info) {
        if (info instanceof CrotoSymbol) {
            CrotoSymbol cs = (CrotoSymbol) info;
            System.err.println(message + " at line " + cs.getLeft().getLine() + ", column " + cs.getLeft().getColumn());
        }
    }
    
    public void report_error(String message, Object info, String message2) {
        if (info instanceof CrotoSymbol) {
            CrotoSymbol cs = (CrotoSymbol) info;
            if (cs.value != null)
                System.err.println(message + " at \"" + cs.value + "\" line " + cs.getLeft().getLine() + ", column " + cs.getLeft().getColumn() + ": " + message2);
            else 
                System.err.println(message + " at \"" + cs.getName() + "\"int line " + cs.getLeft().getLine() + ", column " + cs.getLeft().getColumn() + ": " + message2);
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) {
        done_parsing();
        report_error(message, info);
        System.exit(0);
    }

    @Override
    public void syntax_error(Symbol cur_token) {
        report_error("Sintax error", cur_token, expecetd_tokens_names());
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        report_fatal_error("Fatal sintax error", cur_token);
    }

    protected String expecetd_tokens_names() {
        LinkedList<String> list = new LinkedList<>();
        for (Integer expected : expected_token_ids()) list.add(symbl_name_from_id(expected));
        return "instead expected token are " + list;
    }
:};

init code  {: ts = new TaulaSimbols() :};

/* Types */
terminal BOOLEAN, INTEGER, FLOAT;

/* Keywords */
terminal IF, ELSE;
terminal WHILE, FOR; // loops
terminal BREAK;
terminal RETURN;
terminal CONSTANT;
terminal CROTOFUNC; // Functions

/* Operators */
terminal ASSIGNMENT; // Assignment
terminal ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION; // Aritmetic
terminal EQUAL, DIFFERENT, GREATER, LOWER, GREATER_EQUAL, LOWER_EQUAL; // Comparation
terminal AND, OR, NOT; // Logical

/* Other */
terminal SEMICOLON, COMMA; // Punctuation
terminal LPAREN, RPAREN, LBRACE, RBRACE; // Separators

terminal java.lang.Integer INTEGER_VALUE;
terminal java.lang.Number FLOAT_VALUE;
terminal java.lang.Boolean BOOLEAN_VALUE;
terminal java.lang.String IDENTIFIER; // name

non terminal begin;

non terminal literal; // Modifiers

/* Types */
non terminal type, primitive_type, numeric_type, integral_type;

/* VARIABLE DECLARATIONS*/
non terminal variable_declarators, variable_declarator, variable_declarator_id, variable_initializer;

/* METHOD DECLARATIONS */
non terminal method_declaration, method_header, method_declarator, method_body;
non terminal f_parameter_list_opt, f_parameter_list, f_parameter; // Parameters


/* BLOCKS AND STATEMENTS */
non terminal block, block_statements_opt, block_statements, block_statement;
non terminal local_variable_declaration_statement, local_variable_declaration; 
non terminal statement, statement_with_no_trailing_substatement, statement_expression_list, expression_statement, statement_expression;
non terminal if_statement;
non terminal while_statement;
non terminal for_init, for_statement, for_updt;
non terminal break_statement;
non terminal return_statement;
non terminal primary_not_array;

/* EXPRESSIONS */
non terminal primary;
non terminal argument_list_opt, argument_list;
non terminal method_invocation;
non terminal unary_expression, unary_expression_not_plus_minus;
non terminal additive_expression, multiplicative_expression; // Aritmetic Expressions
non terminal relational_expression;
non terminal conditional_expression, conditional_or_expression, conditional_and_expression, equality_expression; // Conditional Expressions
non terminal assignment_expression, assignment, left_hand_side; // Assignment
non terminal expression_opt, expression;

start with begin;


begin ::= block_statements  {:RESULT = new :}
        | method_declaration; {::}

/* Literal */
literal ::= INTEGER_VALUE | FLOAT_VALUE | BOOLEAN_VALUE ;
	
/* Types */
type ::= primitive_type;
primitive_type ::= numeric_type | BOOLEAN ;
numeric_type ::= integral_type | FLOAT ;
integral_type ::= INTEGER ;


/* Modifiers */

/* VARIABLE DECLARATIONS*/
variable_declarator ::= IDENTIFIER:id | IDENTIFIER ASSIGNMENT expression ; {:RESULT = new Symbol(id,expression)}


/* METHOD DECLARATIONS */
method_declaration ::= method_header method_body ;
method_header ::= CROTOFUNC type method_declarator | CROTOFUNC method_declarator ;
method_declarator ::= IDENTIFIER LPAREN f_parameter_list_opt RPAREN ;
f_parameter_list_opt ::=  | f_parameter_list ;
f_parameter_list ::= f_parameter | f_parameter_list COMMA f_parameter ;
f_parameter ::= CONSTANT type variable_declarator_id | type variable_declarator_id ;
method_body ::= block SEMICOLON ;


/* BLOCKS AND STATEMENTS */
/* Blocks */
block ::= LBRACE block_statements_opt RBRACE ;
block_statements_opt ::=  | block_statements ;
block_statements ::= block_statement | block_statements block_statement ;
block_statement ::= local_variable_declaration_statement | statement ;
local_variable_declaration_statement ::= local_variable_declaration SEMICOLON ;
local_variable_declaration ::= type variable_declarator:e | CONSTANT type variable_declarator:e ; {::}

/* Statements */
statement ::= statement_with_no_trailing_substatement | if_statement | while_statement | for_statement ;
statement_expression_list ::= statement_expression | statement_expression_list COMMA statement_expression ;
statement_with_no_trailing_substatement ::= block | SEMICOLON | expression_statement | break_statement | return_statement ;
expression_statement ::= statement_expression SEMICOLON ;
statement_expression ::= assignment | method_invocation ;

/* If */
if_statement ::= IF LPAREN expression RPAREN block | IF LPAREN expression RPAREN block ELSE block ; {:TS.entrarBloc(); :}

/* While */
while_statement ::= WHILE LPAREN expression RPAREN block ; 

/* For */
for_statement ::= FOR LPAREN for_init SEMICOLON expression_opt SEMICOLON for_updt RPAREN block ;
for_init ::= statement_expression_list | local_variable_declaration |  ;
for_updt ::= statement_expression_list |  ;

/* Other */
break_statement ::= BREAK SEMICOLON ;
return_statement ::= RETURN expression_opt SEMICOLON ;

/* EXPRESSIONS */
primary ::= primary_not_array ;
primary_not_array ::= literal | LPAREN expression RPAREN | method_invocation; 

/* Argument List */
argument_list_opt ::= argument_list |  ;
argument_list ::= expression | argument_list COMMA expression ;

/* Methods */
method_invocation ::= IDENTIFIER LPAREN argument_list_opt RPAREN ;

unary_expression ::= ADDITION unary_expression | SUBTRACTION unary_expression | unary_expression_not_plus_minus ;
unary_expression_not_plus_minus ::= NOT unary_expression ;

/* Aritmetic */
additive_expression ::= multiplicative_expression | additive_expression ADDITION multiplicative_expression | additive_expression SUBTRACTION multiplicative_expression ;
multiplicative_expression ::= unary_expression | multiplicative_expression MULTIPLICATION unary_expression | multiplicative_expression DIVISION unary_expression ; 

/* Relaciones */
relational_expression ::= additive_expression | relational_expression LOWER additive_expression | relational_expression GREATER additive_expression | relational_expression LOWER_EQUAL additive_expression | relational_expression GREATER_EQUAL additive_expression ; 

/* Condiciones logicas */
conditional_expression ::= conditional_or_expression ;
conditional_or_expression ::= conditional_and_expression | conditional_or_expression OR conditional_and_expression ;
conditional_and_expression ::= equality_expression | conditional_and_expression AND equality_expression ;
equality_expression ::= relational_expression | equality_expression EQUAL relational_expression | equality_expression DIFFERENT relational_expression ;

/* Assignment */
assignment_expression ::= conditional_expression | assignment | primary ;
assignment ::= left_hand_side ASSIGNMENT assignment_expression ;
left_hand_side ::= IDENTIFIER ;

expression_opt ::= expression |  ;
expression ::= assignment_expression ;
